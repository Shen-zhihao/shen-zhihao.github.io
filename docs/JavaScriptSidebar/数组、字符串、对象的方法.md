<a name="B33Y0"></a>

# 数组 Array:

<a name="fbXBo"></a>

##### 数组的创建(引用类型)

```javascript
1、使用构造函数创建：
var arr = new Array();    //length属性无法被删除；
var arr2 = new Array(10);    //有且只有一个数字类型的参数表示申明数组长度；
2、使用字面量方式创建   []表示数组；
var arr3 = [];
var arr4['你好'，'再见']；
3、清空数组
arr.length = 0;
4、清除数组
arr = null;
```

<a name="CoDEn"></a>

##### 判断是否是数组

```javascript
数组自带：Array.isArray(arr)方法
数组原型：Array.prototype.isPrototypeOf(arr)方法
原型方法：Object.prototype.toString.call(arr)方法
非严谨方法：arr instanceof Array
```

<a name="feqH7"></a>

##### 遍历

```javascript
1、for循环
  for(i = 0;i<arr.length ; i++){
    console.log(arr[i]);
  }   //正序遍历
2、for in 用来遍历对象（只能遍历可枚举属性，遍历对象的键，会遍历对象的原型链）：
遍历对象（无序存储）：
   for (var key in o){
    console.log(key , o[key]);
  }
遍历数组（有序存储）（空元素无法遍历，不建议使用for in 遍历数组，因为输出的顺序是不固定的）：
  for (var i in arr){
    console.log(arr[i]);
  }
3、for...of是ES6的标准，该方法遍历的是对象的属性所对应的值(value：键值)，所以它用来遍历数组时得到每个元素的值：
for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）
```

<a name="CVnN1"></a>

##### 数组的常用 API

```javascript
1、Array.prototype.push()：在数组尾部插入一个或多个元素,返回值length；
	arr.push(1,2,[4]);   //不会展开数组

2、Array.prototype.pop():删除数组中最后一个元素并返回这个元素,如说是空数组返回undefined；
	arr.pop();

3、Array.prototype.concat():连接（合并）一个或多个数组；不改变原有数组而是新建数组；返回值为一个新数组；
用Array.prototype.concat复制的数组属于浅拷贝，第一层数组属于新建（不会随着原有数组改变），内部嵌套的数组属于内存地址（随着原数组改变发生改变）；

4、Array.prototype.join():将数组中每个元素都转换成字符串连接起来(toString),返回一个字符串；
	arr.join([aeparator]):[aeparator]是分隔符，默认为","；null和undefined没有toString方法，默认为空；
	var str = arr.join();

5、Array.prototype.reverse():用于颠倒数组的所有参数，返回值为原数组；
	arr.reverse();

6、Array.prototype.sort():通过特定的规则给数组排序（默认转化为字符串按照Unicode编码排序），返回值为排序后的原数组；
  arr.sort(function(a,b){
    return a-b;
  });   //升序
  arr.sort(function(a,b){
    return b-a;
  });    //降序
  arr.sort(function(){
    return -1;     //倒序排序
    return 1;      //不变
  });
//按照对象的某个属性值的大小顺序进行排序（从小到大）
  list.sort(function (obj1, obj2) {
      let val1 = +obj1.relation_mark;
      let val2 = +obj2.relation_mark;
      if (val1 < val2) {
        return -1;
      } else if (val1 > val2) {
        return 1;
      } else {
        return 0;
      }
  })

7、Array.prototype.shift():将数组的第一个元素移出数组，其他元素前移，长度减一，返回被删除的元素；

8、Array.prototype.unshift(value):在数组的头部插入元素，返回值为length；

9、Array.prototype.toString():将数组中所有的元素进行toString操作；

10、Array.prototype.slice(start，end):数组中截取一个片段，包含start不包含end；返回值为一个新数组，支持链式调用；
    start(number):开始索引，默认值为0；
    end(number)：结束索引
    结果是新数组的浅拷贝；

11、Array.prototype.splice(start，deleteCount,value):删除数组中的元素（start处），返回值是所有被删除的元素组成的数组；
    start:开始索引；
    deleteCount ：删除步长；
    value：插入的元素；

12、Array.prototype.indexOf():用于在数组中查找元素，如果找到元素则返回索引下标，如果没有返回-1；
   arr.indexOf(selectIndex[fromIndex]):
    selectIndex:索引的元素；
    fromIndex:开始索引的位置；

13、 Array.prototype.forEach():遍历数组为每个数组执行回调函数，修改原数组；
    arr.forEach(function(val){
           //函数表达式
   });

14、Array.prototype.filter():用于在数组中进行检索，检查每一个元素是否符合给定布尔表达式的条件，将符合表达式的元素组成一个新数组；返回一个通过布尔表达式的元素组成的新数组；
   var newArr = arr.filter(function(val){    //val 为arr中的每一个参数
           return 布尔表达式;                 //返回满足表达式(true)的元素
   }):

15、Array.prototype.map():数组的数据映射（遍历数组为每个数组执行回调函数；修改或操作数组中的元素）,返回一个修改后的新数组；
    arr.map(function(val){
       //函数表达式
       return    ;
    })

16、Array.prototype.flatMap():与 map 方法和深度depth为1的flat几乎相同(map后Array.flat(1)）;

17、Array.prototype.reduce():归并、统计；返回归并结果；是一个数组；
    arr.reduce(callback,object):
        object:传入到回调函数的对象；
        callback参数：默认值：prev：上一个   第一次被调用时，是数组的第一个元素；第二次调用时，是上一次的返回值；
                            next：下一个   始终是数组的下一个元素；
            存在参数object时：object
                            currentValue
 求和：var resule = arr.reduce(function(prev,next){return prev+next;})
 统计：var result = arr2.reduce(function (obj,cur){cur % 2? obj.odd++:obj.even++; return obj },{odd:0,even:0} )
      console.log(result)  ;

18、Array.prototype.from(obj [,callback]):    将类数组转化为数组并操作，返回值为一个新数组；
    let arr = Array.from(a)
    Array.from({ length: 5 }, (v, i) => i)   // [0,1,2,3,4]

19、Array.prototype.of(value):              将一组数值转化为数组，返回值为新的数组；
   Array.of(1,2,[3,4],{id:5})

20、Array.prototype.copywithin(target, start, end):  将数组中的元素拷贝到其他位置，返回当前数组；
                                                    target:覆盖的起始索引  start:copy数据的起始索引  end:copy数据的结束索引。

21、Array.prototype.find(callback):         查找满足条件的第一个元素

22、Array.prototype.findIndex(callback):    查找满足条件的第一个元素的索引

23、Array.prototype.includes('value'):      检查某个数组中是否包含某个值；返回一个布尔值

24、Array.prototype.at():                   接收一个整数值并返回该索引的项目，允许正数和负数;用于取出数组中的项。
   Array.at(-1);

25、 Array.prototype.flat()：   该方法可以按照指定的深度将多维数组展开，然后作为一个新数组返回，深度的默认值为 1。如果想要全部展开，只需传递一个 Infinity（无穷大）即可。
    Array.flat(Infinity);

26、Array.prototype.findLast(callback):         查找满足条件的最后元素

27、Array.prototype.findLastIndex(callback):    查找满足条件的最后元素的索引
```

<a name="mQjhl"></a>

# 字符串 String：

<a name="ZvB6X"></a>

##### 常用 Api

```javascript
1、String.prototype.charAt():在字符串中获取指定索引的字符；返回一个字符；
    str.charAt(index)

2、String.prototype.charCodeAt():返回字符串中指定索引字符对应的Unicode编码；返回一个Unicode编码；
    str.charCodeAt(index)
    数字48-57；大写字母：65-90；小写字母：97-122；
   String.prototype.fromCharCode(unicode) :返回Unicode对应的字符；

3、String.prototype.concat() ：将所有字符连接起来；返回一个新字符串；
    str.concat(value)

4、String.prototype.indexOf():在str中查找匹配的字符串；返回值为第一个满足条件的索引值或-1；
    str.indexOf(searchstr,fromindex):
    searchstr：需要在字符串中查找的字符串；
    fromindex：开始查找的位置；

5、 String.prototype.lastIndexOf():用于在字符串中从后向前查找字符串；返回值为第一个满足条件的索引值或-1；
    str.lastIndexOf(searchstr,fromindex):
    searchstr：需要在字符串中查找的字符串；
    fromindex：开始查找的位置；

6、 String.prototype.slice():截取字符串中的字符串片段(索引可以为负数)；返回一个新字符串；如果没有截取到字符串返回空字符串；
    str.slice(start,end):包含start,不包含end；

7、  String.prototype.split():将字符串用指定的分离器切割成多个字符串；返回值是所有字符串组成的新数组；
     str.split(sep):
     sep:分离器，用于切割字符串
     var mail = 'nihao@qq.com';
     var str = mail.split('@');

8、String.prototype.substr():用于在字符串中截取字符串，从start开始；返回值是一个新字符串；
    str.substr(start,length):
    start：开始索引；
    length：长度；

9、String.prototype.substring():用于在字符串中截取片段；返回一个新字符串；
    str.substring(start,end):包含start,不包含end；
                             当start>end时，自动交换两个参数位置；当参数<0或非数字时，当做0；
    start：开始索引；
    end:结束索引；

10、String.prototype.toUpperCase()：转大写
   String.prototype.toLowerCase() ：转小写

11、 String.prototype.at():方法接收一个整数值并返回该索引的项目，允许正数和负数;用于取出字符串中的项。

12、String.prototype.trim() ：去除字符串前后空格。

13、String.prototype.padStart(): 字符串补全长度,从头部开始，返回一个新的字符串，支持链式调用。
   String.prototype.padStart(10,'*')  =>  从头开始处用* 补齐10位

14、String.prototype.padEnd(): 字符串补全长度,从尾部开始，返回一个新的字符串，支持链式调用。
   String.prototype.padEnd(10,'*')  =>  从尾开始处用* 补齐10位

15、String.prototype.trimStart()：方法从字符串的开头删除空格，trimLeft()是此方法的别名。

16、String.prototype.trimEnd()：方法从一个字符串的右端移除空白字符，trimRight()是此方法的别名。

17、String.prototype.replaceAll()：新字符串中所有满足 pattern 的部分都会被replacement 替换；返回一个新字符串；原始字符串保持不变。
  'aabbcc'.replaceAll('b', '.');  =>  'aa..cc'

18、String.prototype.at()：返回是否存在该元素。
  const str = 'Coding Beauty';
	console.log(str.at(-1)); // y
```

<a name="RtyeU"></a>

# 对象:

<a name="elMhE"></a>

##### 创建对象(引用类型)

```javascript
1、构造函数创建：
	var obj = new object();

2、字面量对象创建：
	{}表示创建对象，本质是new object();
	var obj = {键值对，键值对，键值对 };   //key默认是字符串，""可加可不加，包含原型链信息；

3、方法创建
  var obj = Object.create(null)     // 创建的对象不含原型链
```

<a name="bBFA1"></a>

##### 判断是否是 object

```javascript
1、Object.prototype.toString.call(obj) === '[object Object]'
2、instanceof ：任何引用类型([]、{})  obj instanceof Object  的结果都是true;
3、constructor:查看构造函数,返回构造函数名（除了Null、Undefined） arr.constructor.name ;
              (返回构造函数) arr.constructor obj.constructor === Object；
```

<a name="UyyaA"></a>

##### 对象的操作（读取、赋值、删除）

```javascript
1、使用.操作符访问对象的属性
	obj.age
2、访问对象的属性[]
	obj['age'];    //需要带''
3、删除对象的属性delete：
	delete obj.age;
```

<a name="olpyD"></a>

##### 对象的方法

```javascript
1、Object.is:比较两个对象是否相等
    Object.is(value1,value2)

2、Object.assign:对象合并
    Object.assign(target，obj1,obj2,)

3、对象的遍历：
    var obj = { foo: 'bar', baz: 42 };

    //取出对象的key Object.keys
    Object.keys(obj)   => ["foo", "baz"]

    //取出对象的值 Object.values
    Object.values(obj) => ["bar", 42]

4、Object.hasOwnProperty()：key的判断；方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。
   const object1 = {property1：42};
   console.log(object1.hasOwnProperty('property1'));

5、Object.hasOwn()：检查某个对象自身是否拥有某个属性,接收两个参数，一个是对象，一个是属性(ES13)。
   const object1 = {property1：42};
   console.log(Object.hasOwn(object1,'property1'));

6、Object.entries()：返回键值对组成的数组；成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
     Object.entries(obj) => [ ["foo", "bar"], ["baz", 42] ]

7、Object.fromEntries():把键值对列表转换为一个对象，这个方法是和 Object.entries() 相对的。
  数组转换：
     Object.fromEntries([['foo', 1], ['bar', 2] ])    =>   {foo: 1, bar: 2}

  url快速转换：
     const queryString = "?name=jimmy&age=18&height=1.88";
     const queryParams = new URLSearchParams(queryString);
     const paramObj = Object.fromEntries(queryParams);
     console.log(paramObj);   =>   { name: 'jimmy', age: '18', height: '1.88' }
```

<a name="DgUuh"></a>

##### json 字符串

```javascript
var str = '{"username":"lisi","age"= 18}';    //外层''，内层属性名(key)加"";

将json转化为字符串(JSON.stringify)：
  var str = JSON.stringify(obj);

将json字符串转化为json对象(JSON.parse)：
  var str = '{"username":"lisi","age"= 18}';
  var o2 = JSON.parse(str);
```

<a name="UMbcv"></a>

# 深浅拷贝:

<a name="FaylT"></a>

##### 对象的浅拷贝

```javascript
1、const obj2 = Object.assign({},obj1)      //相当于对象合并,新增的对象方法
2、const obj2 = {...obj1}                  //展开运算
```

<a name="aSo74"></a>

##### 数组的拷贝

```javascript
concat方法 和 展开运算 对于一维数组基本类型是深拷贝，对于二维数组是浅拷贝；

const arr2 = [].concat(arr1);           //数组合并
const arr2 = [...arr1];                 //数组展开
```

<a name="R5ltX"></a>

##### 对象的深拷贝

```javascript
const obj2 = JSON.parse(JSON.stringify(obj1)); //转字符串再转回来，部分无法转换（function方法）
```

<a name="r8s7U"></a>

##### 循环遍历深拷贝

```javascript
function deepCopy(obj) {
  let newobj = obj.constructor === Array ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (obj[key] && typeof obj[key] === "object") {
        newobj[key] = deepCopy(obj[key]);
      } else {
        newobj[key] = obj[key];
      }
    }
  }
  return newobj;
}
```

<a name="S5dhw"></a>

##### 深拷贝解决对象的循环引用

```javascript
核心思路：可以使用递归实现深拷贝，并使用一个Map来记录已经拷贝过的对象，避免循环引用的问题。
function deepClone(obj, map = new Map()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (map.has(obj)) {
    return map.get(obj);
  }

  let clone = Array.isArray(obj) ? [] : {};

  map.set(obj, clone);

  for (let key in obj) {
    clone[key] = deepClone(obj[key], map);
  }

  return clone;
}
```
